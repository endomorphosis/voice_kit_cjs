{"version":3,"file":"popup.js","mappings":"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","sources":["webpack://browser-extension/webpack/bootstrap","webpack://browser-extension/webpack/runtime/get javascript chunk filename","webpack://browser-extension/webpack/runtime/hasOwnProperty shorthand","webpack://browser-extension/webpack/runtime/publicPath","webpack://browser-extension/webpack/runtime/jsonp chunk loading","webpack://browser-extension/./src/popup.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".js\";\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","__webpack_require__.p = \"/\";","__webpack_require__.b = document.baseURI || self.location.href;\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t887: 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n// no on chunks loaded\n\n// no jsonp function","// popup.js - handles interaction with the extension's popup UI\r\nimport { ACTION_NAME } from \"./constants.js\";\r\n\r\n// Set WASM path for workers\r\nglobalThis.__TRANSFORMER_WORKER_WASM_PATH__ = '/wasm/';\r\n\r\n// Get UI elements\r\nconst outputElement = document.getElementById(\"output\");\r\nconst chatInput = document.getElementById('chat-input');\r\nconst sendButton = document.getElementById('send-button');\r\nconst chatMessages = document.getElementById('chat-messages');\r\nconst micButton = document.getElementById('mic-button');\r\nconst logMessages = document.getElementById('log-messages');\r\n\r\n// Keep track of connection status\r\nlet isConnected = false;\r\nlet reconnectAttempts = 0;\r\nconst MAX_RECONNECT_ATTEMPTS = 3;\r\n\r\n// Function to check connection with background script\r\nasync function checkConnection() {\r\n    try {\r\n        await chrome.runtime.sendMessage({ type: 'check_status' });\r\n        isConnected = true;\r\n        reconnectAttempts = 0;\r\n        return true;\r\n    } catch (error) {\r\n        console.warn('Connection error:', error);\r\n        isConnected = false;\r\n        \r\n        if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {\r\n            reconnectAttempts++;\r\n            console.log(`Retrying connection... Attempt ${reconnectAttempts}`);\r\n            await new Promise(resolve => setTimeout(resolve, 1000 * reconnectAttempts));\r\n            return checkConnection();\r\n        } else {\r\n            updateStatus({\r\n                status: 'error',\r\n                data: 'Could not connect to extension. Please try reloading.'\r\n            });\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\r\n// Listen for messages from the background script\r\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\r\n    console.log('Popup received message:', message);\r\n    isConnected = true;\r\n    updateStatus(message);\r\n});\r\n\r\nfunction updateStatus(message) {\r\n    const statusEl = document.getElementById('status');\r\n    const statusIndicator = document.getElementById('status-indicator');\r\n    const progressEl = document.getElementById('loading-progress');\r\n    \r\n    if (!statusEl || !statusIndicator) return;\r\n\r\n    statusIndicator.className = message.status;\r\n    \r\n    if (message.status === 'loading') {\r\n        statusEl.textContent = 'Loading model...';\r\n        if (message.progress) {\r\n            progressEl.textContent = `${message.progress.toFixed(1)}%`;\r\n        }\r\n    } else if (message.status === 'error') {\r\n        statusEl.textContent = `Error: ${message.data}`;\r\n        statusIndicator.className = 'error';\r\n        progressEl.textContent = '';\r\n    } else if (message.status === 'ready') {\r\n        statusEl.textContent = 'Model ready';\r\n        statusIndicator.className = 'ready';\r\n        progressEl.textContent = '';\r\n    }\r\n}\r\n\r\n// Enhanced initialization\r\ndocument.addEventListener('DOMContentLoaded', async () => {\r\n    console.log('Popup opened');\r\n    \r\n    // Initial connection check\r\n    if (await checkConnection()) {\r\n        console.log('Connected to extension');\r\n    }\r\n    \r\n    // Set up periodic connection checks\r\n    setInterval(checkConnection, 5000);\r\n    \r\n    try {\r\n        await Promise.all([\r\n            initASR(),\r\n            cacheIcon()\r\n        ]);\r\n        console.log('Initialization complete');\r\n    } catch (error) {\r\n        console.error('Initialization failed:', error);\r\n        addLogEntry('error', 'Failed to initialize: ' + error.message);\r\n    }\r\n});\r\n\r\n// Console logging override\r\nconst originalConsole = {\r\n    log: console.log,\r\n    error: console.error,\r\n    info: console.info\r\n};\r\n\r\nfunction addLogEntry(type, ...args) {\r\n    const entry = document.createElement('div');\r\n    entry.className = `log-entry ${type}`;\r\n    entry.textContent = args.map(arg => \r\n        typeof arg === 'object' ? JSON.stringify(arg) : arg\r\n    ).join(' ');\r\n    logMessages?.appendChild(entry);\r\n    logMessages?.scrollTo(0, logMessages.scrollHeight);\r\n    return originalConsole[type](...args);\r\n}\r\n\r\nconsole.log = (...args) => addLogEntry('info', ...args);\r\nconsole.error = (...args) => addLogEntry('error', ...args);\r\nconsole.info = (...args) => addLogEntry('info', ...args);\r\n\r\n// Chat functionality\r\nfunction addMessage(content, isUser = false) {\r\n    const messageDiv = document.createElement('div');\r\n    messageDiv.className = `message ${isUser ? 'user' : 'assistant'}`;\r\n    messageDiv.textContent = content;\r\n    chatMessages.appendChild(messageDiv);\r\n    chatMessages.scrollTo(0, chatMessages.scrollHeight);\r\n}\r\n\r\nasync function sendMessage() {\r\n    const text = chatInput.value.trim();\r\n    if (!text) return;\r\n\r\n    // Check connection first\r\n    if (!isConnected && !await checkConnection()) {\r\n        const errorDiv = document.createElement('div');\r\n        errorDiv.className = 'message assistant error-message';\r\n        errorDiv.textContent = 'Not connected to extension. Please reload the popup.';\r\n        chatMessages.appendChild(errorDiv);\r\n        return;\r\n    }\r\n\r\n    // Show loading state\r\n    const messageDiv = document.createElement('div');\r\n    messageDiv.className = 'message user';\r\n    messageDiv.textContent = text;\r\n    chatMessages.appendChild(messageDiv);\r\n    \r\n    // Clear input and add loading indicator\r\n    chatInput.value = '';\r\n    const loadingDiv = document.createElement('div');\r\n    loadingDiv.className = 'message assistant';\r\n    loadingDiv.innerHTML = '<span class=\"loading-spinner\"></span> Generating response...';\r\n    chatMessages.appendChild(loadingDiv);\r\n    chatMessages.scrollTo(0, chatMessages.scrollHeight);\r\n    \r\n    try {\r\n        const response = await new Promise((resolve, reject) => {\r\n            chrome.runtime.sendMessage({\r\n                action: 'generate',\r\n                text: text\r\n            }, response => {\r\n                if (chrome.runtime.lastError) {\r\n                    reject(new Error(chrome.runtime.lastError.message));\r\n                    return;\r\n                }\r\n                resolve(response);\r\n            });\r\n        });\r\n        \r\n        // Remove loading indicator\r\n        loadingDiv.remove();\r\n        \r\n        if (response?.error) {\r\n            const errorDiv = document.createElement('div');\r\n            errorDiv.className = `message assistant error-message ${response.error.includes('memory') ? 'recoverable' : ''}`;\r\n            \r\n            // Format error message for users\r\n            let errorMessage = response.error;\r\n            if (response.error.includes('1879778072') || response.error.includes('memory')) {\r\n                errorMessage = 'The message was too long to process. Try sending a shorter message or breaking it into smaller parts.';\r\n            }\r\n            \r\n            errorDiv.textContent = errorMessage;\r\n            chatMessages.appendChild(errorDiv);\r\n            \r\n            // Add memory usage warning if relevant\r\n            if (response.error.includes('memory')) {\r\n                const warningDiv = document.createElement('div');\r\n                warningDiv.className = 'memory-warning';\r\n                warningDiv.textContent = 'Tip: Keep messages under 2000 characters for best performance.';\r\n                chatMessages.appendChild(warningDiv);\r\n            }\r\n        } else {\r\n            const responseDiv = document.createElement('div');\r\n            responseDiv.className = 'message assistant';\r\n            responseDiv.textContent = response;\r\n            chatMessages.appendChild(responseDiv);\r\n        }\r\n    } catch (error) {\r\n        // Remove loading indicator\r\n        loadingDiv.remove();\r\n        \r\n        const errorDiv = document.createElement('div');\r\n        errorDiv.className = 'message assistant error-message';\r\n        errorDiv.textContent = 'Error: ' + (error.message || 'Could not connect to extension. Please try reloading.');\r\n        chatMessages.appendChild(errorDiv);\r\n        console.error('Error sending message:', error);\r\n        \r\n        // Try to reconnect\r\n        checkConnection();\r\n    }\r\n    \r\n    chatMessages.scrollTo(0, chatMessages.scrollHeight);\r\n}\r\n\r\nsendButton.addEventListener('click', sendMessage);\r\nchatInput.addEventListener('keypress', (e) => {\r\n    if (e.key === 'Enter' && !e.shiftKey) {\r\n        e.preventDefault();\r\n        sendMessage();\r\n    }\r\n});\r\n\r\n// Speech recognition setup\r\nlet mediaRecorder = null;\r\nlet recordedChunks = [];\r\nlet asrWorker = null;\r\n\r\nasync function initASR() {\r\n    try {\r\n        console.log('Initializing ASR worker...');\r\n        asrWorker = new Worker(new URL('./asr-worker.js', import.meta.url), { type: 'module' });\r\n        \r\n        asrWorker.onerror = (error) => {\r\n            console.error('ASR worker error:', error);\r\n            addLogEntry('error', 'ASR worker error:', error.message);\r\n        };\r\n        \r\n        return new Promise((resolve, reject) => {\r\n            const timeout = setTimeout(() => {\r\n                reject(new Error('ASR worker initialization timed out'));\r\n            }, 30000); // 30 second timeout\r\n            \r\n            asrWorker.onmessage = (event) => {\r\n                const { type, text, error } = event.data;\r\n                \r\n                if (type === 'ready') {\r\n                    console.log('ASR worker ready');\r\n                    clearTimeout(timeout);\r\n                    micButton.disabled = false;\r\n                    resolve();\r\n                } else if (type === 'transcription') {\r\n                    chatInput.value = (chatInput.value + ' ' + text).trim();\r\n                } else if (type === 'error') {\r\n                    console.error('ASR error:', error);\r\n                    addLogEntry('error', 'ASR error:', error);\r\n                }\r\n            };\r\n        });\r\n    } catch (error) {\r\n        console.error('Error initializing ASR:', error);\r\n        addLogEntry('error', 'Failed to initialize speech recognition');\r\n        micButton.disabled = true;\r\n        throw error;\r\n    }\r\n}\r\n\r\n// Disable mic button initially\r\nmicButton.disabled = true;\r\n\r\n// Download and cache the Copilot avatar\r\nasync function cacheIcon() {\r\n    try {\r\n        const response = await fetch('https://avatars.githubusercontent.com/u/123265934');\r\n        const blob = await response.blob();\r\n        const iconUrl = URL.createObjectURL(blob);\r\n        const links = document.querySelectorAll('link[rel*=\"icon\"]');\r\n        links.forEach(link => {\r\n            link.href = iconUrl;\r\n        });\r\n    } catch (error) {\r\n        console.error('Failed to cache icon:', error);\r\n    }\r\n}\r\n\r\nasync function requestMicrophonePermissions() {\r\n    try {\r\n        // Check if permissions are already granted\r\n        const permissions = await navigator.permissions.query({ name: 'microphone' });\r\n        \r\n        if (permissions.state === 'granted') {\r\n            return true;\r\n        } else if (permissions.state === 'prompt') {\r\n            // Show instructions to user before requesting permissions\r\n            addLogEntry('info', 'Please allow microphone access in the browser prompt');\r\n            // Request permissions explicitly\r\n            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\r\n            stream.getTracks().forEach(track => track.stop()); // Clean up test stream\r\n            return true;\r\n        } else if (permissions.state === 'denied') {\r\n            addLogEntry('error', 'Microphone access is blocked. Please allow access in your browser settings.');\r\n            // Show instructions for enabling permissions\r\n            const instructions = document.createElement('div');\r\n            instructions.className = 'log-entry info';\r\n            instructions.innerHTML = `\r\n                To enable microphone access:\r\n                <ol>\r\n                    <li>Click the camera/microphone icon in your browser's address bar</li>\r\n                    <li>Select \"Allow\" for microphone access</li>\r\n                    <li>Refresh this page</li>\r\n                </ol>\r\n            `;\r\n            logMessages.appendChild(instructions);\r\n            return false;\r\n        }\r\n    } catch (error) {\r\n        console.error('Error checking permissions:', error);\r\n        return false;\r\n    }\r\n}\r\n\r\nasync function startRecording() {\r\n    try {\r\n        // Check permissions first\r\n        const hasPermission = await requestMicrophonePermissions();\r\n        if (!hasPermission) {\r\n            micButton.classList.remove('recording');\r\n            return;\r\n        }\r\n\r\n        console.log('Requesting microphone access...');\r\n        const constraints = { \r\n            audio: {\r\n                channelCount: 1,\r\n                sampleRate: 16000\r\n            }\r\n        };\r\n        \r\n        const stream = await navigator.mediaDevices.getUserMedia(constraints);\r\n        console.log('Microphone access granted:', stream.getAudioTracks()[0].getSettings());\r\n        \r\n        mediaRecorder = new MediaRecorder(stream, {\r\n            mimeType: 'audio/webm;codecs=opus'\r\n        });\r\n        console.log('MediaRecorder created with settings:', mediaRecorder.mimeType);\r\n        \r\n        mediaRecorder.ondataavailable = (event) => {\r\n            if (event.data.size > 0) {\r\n                recordedChunks.push(event.data);\r\n                console.log('Recorded chunk size:', event.data.size);\r\n            }\r\n        };\r\n        \r\n        mediaRecorder.onerror = (event) => {\r\n            console.error('MediaRecorder error:', event.error);\r\n        };\r\n        \r\n        mediaRecorder.onstop = async () => {\r\n            try {\r\n                console.log('Recording stopped, processing audio...');\r\n                const audioBlob = new Blob(recordedChunks, { type: 'audio/webm' });\r\n                console.log('Audio blob created, size:', audioBlob.size);\r\n                recordedChunks = [];\r\n                \r\n                // Convert audio to proper format for Whisper\r\n                const audioContext = new AudioContext({ sampleRate: 16000 });\r\n                const audioData = await audioBlob.arrayBuffer();\r\n                console.log('Audio data size:', audioData.byteLength);\r\n                \r\n                const audioBuffer = await audioContext.decodeAudioData(audioData);\r\n                console.log('Audio decoded, duration:', audioBuffer.duration);\r\n                \r\n                // Get audio data as Float32Array\r\n                const audio = audioBuffer.getChannelData(0);\r\n                console.log('Audio converted to Float32Array, length:', audio.length);\r\n                \r\n                // Send to worker for transcription\r\n                if (asrWorker) {\r\n                    asrWorker.postMessage({ buffer: audio });\r\n                    console.log('Audio sent to ASR worker');\r\n                } else {\r\n                    console.error('ASR worker not initialized');\r\n                }\r\n                \r\n                // Clean up\r\n                stream.getTracks().forEach(track => {\r\n                    track.stop();\r\n                    console.log('Audio track stopped:', track.label);\r\n                });\r\n                micButton.classList.remove('recording');\r\n                \r\n            } catch (error) {\r\n                console.error('Error processing recorded audio:', error);\r\n                if (error.name === 'InvalidStateError') {\r\n                    console.error('Audio context error - possible sample rate or format issue');\r\n                }\r\n                addLogEntry('error', 'Error processing audio:', error.message);\r\n            }\r\n        };\r\n        \r\n        mediaRecorder.start(1000); // Collect data in 1-second chunks\r\n        console.log('Recording started');\r\n        micButton.classList.add('recording');\r\n        \r\n    } catch (error) {\r\n        console.error('Error starting recording:', {\r\n            name: error.name,\r\n            message: error.message,\r\n            constraint: error.constraint,\r\n            stack: error.stack\r\n        });\r\n        \r\n        let errorMessage = 'Could not start recording: ';\r\n        if (error.name === 'NotAllowedError') {\r\n            // Don't show this message since we handle it in requestMicrophonePermissions\r\n            return;\r\n        } else if (error.name === 'NotFoundError') {\r\n            errorMessage += 'No microphone was found';\r\n        } else if (error.name === 'NotReadableError') {\r\n            errorMessage += 'Microphone is already in use by another application';\r\n        } else {\r\n            errorMessage += error.message || 'Unknown error';\r\n        }\r\n        \r\n        addLogEntry('error', errorMessage);\r\n        micButton.classList.remove('recording');\r\n    }\r\n}\r\n\r\nfunction stopRecording() {\r\n    if (mediaRecorder && mediaRecorder.state === 'recording') {\r\n        mediaRecorder.stop();\r\n    }\r\n}\r\n\r\n// Initialize ASR when popup is loaded\r\ndocument.addEventListener('DOMContentLoaded', () => {\r\n    initASR();\r\n});\r\n\r\n// Add click handler for mic button\r\nmicButton.addEventListener('click', () => {\r\n    if (!mediaRecorder || mediaRecorder.state === 'inactive') {\r\n        startRecording();\r\n    } else {\r\n        stopRecording();\r\n    }\r\n});\r\n"],"names":["__webpack_require__","chunkId","obj","prop","Object","prototype","hasOwnProperty","call","b","document","baseURI","self","location","href","globalThis","__TRANSFORMER_WORKER_WASM_PATH__","getElementById","chatInput","sendButton","chatMessages","micButton","logMessages","isConnected","reconnectAttempts","async","checkConnection","chrome","runtime","sendMessage","type","error","console","warn","log","Promise","resolve","setTimeout","updateStatus","status","data","message","statusEl","statusIndicator","progressEl","className","textContent","progress","toFixed","onMessage","addListener","sender","sendResponse","addEventListener","setInterval","all","initASR","cacheIcon","addLogEntry","originalConsole","info","args","entry","createElement","map","arg","JSON","stringify","join","appendChild","scrollTo","scrollHeight","text","value","trim","errorDiv","messageDiv","loadingDiv","innerHTML","response","reject","action","lastError","Error","remove","includes","errorMessage","warningDiv","responseDiv","e","key","shiftKey","preventDefault","mediaRecorder","recordedChunks","asrWorker","Worker","URL","onerror","timeout","onmessage","event","clearTimeout","disabled","fetch","blob","iconUrl","createObjectURL","querySelectorAll","forEach","link","state","stop","permissions","navigator","query","name","mediaDevices","getUserMedia","audio","getTracks","track","instructions","requestMicrophonePermissions","classList","constraints","channelCount","sampleRate","stream","getAudioTracks","getSettings","MediaRecorder","mimeType","ondataavailable","size","push","onstop","audioBlob","Blob","audioContext","AudioContext","audioData","arrayBuffer","byteLength","audioBuffer","decodeAudioData","duration","getChannelData","length","postMessage","buffer","label","start","add","constraint","stack","startRecording"],"sourceRoot":""}